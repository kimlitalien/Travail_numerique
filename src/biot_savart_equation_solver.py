import numpy as np
import math
from scipy.constants import mu_0, pi

from src.coordinate_and_position import CoordinateSystem
from src.fields import VectorField


class BiotSavartEquationSolver:
    """
    A Biot–Savart law solver used to compute the resultant magnetic field B in 2D-space generated by a constant current
    field I (for example due to wires).
    """

    def _solve_in_cartesian_coordinate(
            self,
            electric_current: VectorField,
            delta_x: float,
            delta_y: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (x, y) → (I_x(x, y), I_y(x, y), I_z(x, y)), where I_x(x, y), I_y(x, y) and
            I_z(x, y) are the 3 components of the electric current vector at a given point (x, y) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_x : float
            Small discretization of the x-axis.
        delta_y : float
            Small discretization of the y-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (x, y) → (B_x(x, y), B_y(x, y), B_z(x, y)), where B_x(x, y), B_y(x, y) and
            B_z(x, y) are the 3 components of the magnetic vector at a given point (x, y) in space. Note that
            B_x = B_y = 0 is always True in our 2D world.
        """

        #on détermine les dimensions du electric_current à parcourir
        x, y, z = electric_current.shape
        #on initialise un champ magnétique total nul de même dimension que le electric_current
        champ_total = np.zeros((x, y, 3))
        #on itère sur tous les points de l'espace
        for j in range(y):
            for i in range(x):
                #on vérfie s'il y a un courant au point (i,j)
                if electric_current[i, j][0] != 0 or electric_current[i, j][1] != 0:
                    #on initialise un champ produit par le point(i,j)
                    champ = np.zeros((x, y, 3))
                    #on trouve les distances en x et y entre le point (i,j) et tous les points de l'espace
                    rx, ry = np.meshgrid(np.arange(x) - i, np.arange(y) - j)
                    norme_r = np.sqrt(rx ** 2 + ry ** 2)
                    #on crée un masque pour éviter les divisions par 0
                    masque = norme_r != 0
                    #on calcule le vecteur r
                    vecteur_r = np.stack((-rx, -ry, np.zeros_like(rx)), axis=-1)
                    #on calcule le produit vectoriel
                    I_x_r = np.cross(vecteur_r, electric_current[i, j]) 
                    #on calcul le champ magnétique produit par l'élément de courant (i,j) sur tous les points de l'espace
                    champ[masque] = (mu_0 / (4 * np.pi)) * (I_x_r[masque] / norme_r[masque, np.newaxis] ** 3)
                    #on ajoute le champ produit par le point (i,j) au champ total
                    champ_total += champ
        return VectorField(champ_total)



    def _solve_in_polar_coordinate(
            self,
            electric_current: VectorField,
            delta_r: float,
            delta_theta: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (r, θ) → (I_r(r, θ), I_θ(r, θ), I_z(r, θ)), where I_r(r, θ), I_θ(r, θ) and
            I_z(r, θ) are the 3 components of the electric current vector at a given point (r, θ) in space. Note that
            I_z = 0 is always True in our 2D world.
        delta_r : float
            Small discretization of the r-axis.
        delta_theta : float
            Small discretization of the θ-axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (r, θ) → (B_r(r, θ), B_θ(r, θ), B_z(r, θ)), where B_r(r, θ), B_θ(r, θ) and
            B_z(r, θ) are the 3 components of the magnetic vector at a given point (r, θ) in space. Note that
            B_r = B_θ = 0 is always True in our 2D world.
        """
        #on détermine les dimensions du electric_current à parcourir
        x, y, z = electric_current.shape
        #on initialise un champ magnétique total nul de même dimension que le electric_current
        champ_total = np.zeros((x, y, 3))
        #on parcourt tous les points en x
        for i in range(x):
            #on parcourt tous les points en y
            for j in range(y):
                #on vérifie si au moins une composante du courant n'est pas nul
                if electric_current[i,j][0] != 0 or electric_current[i,j][1] != 0:
                    #on initialise un champ magnétique produit par l'element de courant (i,j)
                    champ = np.zeros((x, y, 3))
                    #si c'est le cas, calcule la contribution au champ du point (i,j) pour tous les points de l'espace
                    for k in range(x):
                        for l in range(y):
                            #on veut juste calculer le champ pour les points de l'espace où il n'y a pas d'élément de courant
                            if electric_current[k,l][0] == 0 and electric_current[k,l][1] == 0:
                                #on cherche la distance entre l'élement de courant(i,j) et le point où on cherche le champ(k,l)
                                rx = i-k
                                ry = j-l
                                norme_r = math.sqrt(rx**2 + ry**2)
                                vecteur_r = -np.array([rx, ry, 0])
                                I_x_r = np.cross(electric_current[i,j], vecteur_r)
                                #on applique la loi de Biot-Savart
                                champ[k,l] = (mu_0 / (4 * pi)) * (I_x_r / norme_r**3)
                    #on ajoute le champ produit par chaque élément de courant au champ total
                    champ_total = champ_total + champ
        return VectorField(champ_total) 



                                
                                


    def solve(
            self,
            electric_current: VectorField,
            coordinate_system: CoordinateSystem,
            delta_q1: float,
            delta_q2: float
    ) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ representing currents in the 2D world.
        coordinate_system : CoordinateSystem
            Coordinate system.
        delta_q1 : float
            Small discretization of the first axis.
        delta_q2 : float
            Small discretization of the second axis.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ representing the magnetic field in the 2D world.
        """
        if coordinate_system == CoordinateSystem.CARTESIAN:
            return self._solve_in_cartesian_coordinate(electric_current, delta_q1, delta_q2)
        elif coordinate_system == CoordinateSystem.POLAR:
            return self._solve_in_polar_coordinate(electric_current, delta_q1, delta_q2)
        else:
            raise NotImplementedError("Only the cartesian and polar coordinates solvers are implemented.")
